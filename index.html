<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Meta tags for social media banners, these should be filled in appropriatly as they are your "business card" -->
  <!-- Replace the content tag with appropriate information -->
  <meta name="description" content="DESCRIPTION META TAG">
  <meta property="og:title" content="SOCIAL MEDIA TITLE TAG"/>
  <meta property="og:description" content="SOCIAL MEDIA DESCRIPTION TAG TAG"/>
  <meta property="og:url" content="URL OF THE WEBSITE"/>
  <!-- Path to banner image, should be in the path listed below. Optimal dimenssions are 1200X630-->
  <meta property="og:image" content="static/image/your_banner_image.png" />
  <meta property="og:image:width" content="1200"/>
  <meta property="og:image:height" content="630"/>


  <meta name="twitter:title" content="TWITTER BANNER TITLE META TAG">
  <meta name="twitter:description" content="TWITTER BANNER DESCRIPTION META TAG">
  <!-- Path to banner image, should be in the path listed below. Optimal dimenssions are 1200X600-->
  <meta name="twitter:image" content="static/images/your_banner_image.png">
  <meta name="twitter:card" content="summary_large_image">
  <!-- Keywords for your paper to be indexed by-->
  <meta name="keywords" content="KEYWORDS SHOULD BE PLACED HERE">
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <title>C-MCTD</title>
  <link rel="icon" type="image/x-icon" href="static/images/mctd.ico">
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro"
  rel="stylesheet">

  <link rel="stylesheet" href="static/css/bulma.min.css">
  <link rel="stylesheet" href="static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="static/css/fontawesome.all.min.css">
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="static/css/index.css">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>
  <script defer src="static/js/fontawesome.all.min.js"></script>
  <script src="static/js/bulma-carousel.min.js"></script>
  <script src="static/js/bulma-slider.min.js"></script>
  <script src="static/js/index.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        processEscapes: true
      }
    };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>


  <section class="hero">
    <div class="hero-body">
      <div class="container is-max-desktop">
        <div class="columns is-centered">
          <div class="column has-text-centered">
            <h1 class="title is-1 publication-title">Compositional Monte Carlo Tree Diffusion for Extendable Planning</h1>
            <div class="is-size-5 publication-authors">
              <!-- Paper authors -->
              <span class="author-block">
                <a href="https://jaesikyoon.com" target="_blank">Jaesik Yoon</a><sup>1,2</sup>,
              </span>
              <span class="author-block">
                Hyeonseo Cho<sup>1</sup>,
              </span>
              <span class="author-block">
                <a href="https://mlml.kaist.ac.kr/sungjinahn" target="_blank">Sungjin Ahn</a><sup>1,3</sup>
              </span>
              </div>

              <div class="is-size-5 publication-authors">
                <span class="author-block"><sup>1</sup>KAIST, <sup>2</sup>SAP, <sup>3</sup>NYU
                  <br>NeurIPS 2025, <span style="color: #8FBC8F; font-style: italic;">Spotlight (top 3.2% of submissions)</span>
                </span>
                </span>
              </div>

              <div class="column has-text-centered">
                <div class="publication-links">
                  <!-- Arxiv PDF link -->
                  <span class="link-block">
                    <a href="https://arxiv.org/pdf/2510.21361" target="_blank"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="fas fa-file-pdf"></i>
                    </span>
                    <span>Paper</span>
                    </a>
                  </span>

                  <!-- ArXiv abstract Link -->
                  <span class="link-block">
                    <a href="https://arxiv.org/abs/2510.21361" target="_blank"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="ai ai-arxiv"></i>
                    </span>
                    <span>arXiv</span>
                    </a>
                  </span>

                  <!-- MCTD Page link -->
                  <span class="link-block">
                    <a href="https://jaesikyoon.com/mctd-page/" target="_blank"
                    class="external-link button is-normal is-rounded is-dark">
                    <span class="icon">
                      <i class="fas fa-link"></i>
                    </span>
                    <span>MCTD Page</span>
                    </a>
                  </span>

        </div>
      </div>
    </div>
  </div>
</div>
</section>


<!-- Teaser image-->
<section class="hero teaser">
  <div class="container is-max-desktop">
    <div class="hero-body">
      <div class="banner-videos" style="display: flex; gap: 16px; justify-content: center; align-items: center;">
        <img src="static/images/c_mctd_maze_illustration.png" alt="Key Result" style="max-width: 100%; height: auto;">
      </div>
      <br>
      <h2 class="subtitle has-text-centered">
        Monte Carlo Tree Diffusion (MCTD) effectively tackles complex planning tasks by combining diffusion models with structured tree search.
        However, its core limitation is the inability to generate these high-quality plans for longer trajectories than seen during training.
        We propose Compositional MCTD (C-MCTD), a framework that overcomes this by generating a globally coherent plan from smaller, individually generated trajectory segments.
      </h2>
    </div>
  </div>
</section>
<!-- End teaser image -->

<!-- Paper abstract -->
<section class="section hero is-light">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            Monte Carlo Tree Diffusion (MCTD) integrates diffusion models with structured tree search to enable effective trajectory exploration through stepwise reasoning. However, MCTD remains fundamentally limited by training trajectory lengths. While periodic replanning allows plan concatenation for longer plan generation, the planning process remains locally confined, as MCTD searches within individual trajectories without access to global context. We propose Compositional Monte Carlo Tree Diffusion (C-MCTD), a framework that elevates planning from individual trajectory optimization to reasoning over complete plan compositions. C-MCTD introduces three complementary components: (1) Online Composer, which performs globally-aware planning by searching across entire plan compositions; (2) Distributed Composer, which reduces search complexity through parallel exploration from multiple starting points; and (3) Preplan Composer, which accelerates inference by leveraging cached plan graphs.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>
<!-- End paper abstract -->

<!-- MCTD -->
<section class="section hero is-light">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Preliminary: Monte Carlo Tree Diffusion (MCTD)</h2>
        <div class="content has-text-justified">
          <p>
            Our work builds upon <strong><a href="https://jaesikyoon.com/mctd-page/" target="_blank" style="text-decoration: underline;">Monte Carlo Tree Diffusion (MCTD)</a></strong>, a framework that reframes trajectory planning as a tree search problem by integrating the generative power of diffusion models with the structured search capabilities of MCTS.
            The framework is built on three key concepts:
          </p>
          <p>
            <strong>1. Denoising as Tree Rollout</strong><br>
            Unlike conventional MCTS which performs rollouts at the state level, MCTD operates on <strong>subplans</strong>—segments of the full trajectory. A complete trajectory $\mathbf{x}$ is partitioned into a sequence $[\mathbf{x}_1, \dots, \mathbf{x}_S]$.
            By generating these semi-autoregressively, MCTD performs intermediate evaluations akin to MCTS rollouts.
            This approach effectively reduces the search tree's depth while preserving the global coherence of diffusion models.
            $$
              \begin{align}
                p(\mathbf{x}) \approx \prod_{s=1}^S p(\mathbf{x}_s|\mathbf{x}_{1:s-1})
              \end{align}
            $$
          </p>
          <p>
              <strong>2. Guidance Levels as Meta-Actions</strong><br>
              To manage the exploration-exploitation trade-off, MCTD introduces <strong>guidance levels</strong> as meta-actions. For each subplan $\mathbf{x}_s$, a discrete control mode—such as $\text{GUIDE}$ or $\text{NO_GUIDE}$—is selected.
              By dynamically controlling the guidance level $g_s$ for each subplan, MCTD can balance exploration and exploitation within a single, unified denoising process.
              $$
                \begin{align}
                  p(\mathbf{x}|\mathbf{g}) \approx \prod_{s=1}^S p(\mathbf{x}_s|\mathbf{x}_{1:s-1}, g_s)
                \end{align}
              $$
          </p>
          <p>
              <strong>3. Jumpy Denoising as Fast Simulation</strong><br>
              For efficient simulation, MCTD utilizes a fast, <strong>jumpy denoising</strong> process based on the Denoising Diffusion Implicit Model (DDIM) (<a href="https://arxiv.org/abs/2010.02502" target="_blank" style="text-decoration: underline;">Song et al., 2020</a>).
              This technique significantly accelerates the search process while maintaining high-quality trajectory generation for evaluation.
              $$
                \begin{align}
                  \tilde{\mathbf{x}}_{s+1:S} \sim p(\mathbf{x}_{s+1:S}|\mathbf{x}_{1:s}, \mathbf{g})
                \end{align}
              $$
          </p>
          <p>
              <strong>Four Canonical Steps of MCTD</strong><br>
              MCTD implements these components through a modified MCTS procedure. The four canonical steps—Selection, Expansion, Simulation, and Backpropagation—are adapted to handle subplan generation within this diffusion-based planning process.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- C-MCTD -->
<section class="section hero is-light">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Compositional Monte Carlo Tree Diffusion</h2>
        <div class="content has-text-justified">
          <p>
            While MCTD performs impressively on complex planning tasks, it struggles to generate plans that are longer than the trajectories seen during training.
            A common workaround is to simply generate a new plan when the old one ends.
            However, this "replanning" approach is inherently <strong>myopic</strong>—it makes decisions based only on the immediate situation, often leading to dead ends or inefficient, suboptimal paths.
          </p>
          <p>
            To overcome this fundamental limitation, we propose <strong>Compositional Monte Carlo Tree Diffusion (C-MCTD)</strong>.
            Our framework constructs a globally coherent, long-horizon plan by intelligently <strong>composing</strong> shorter, high-quality plan segments.
            This allows C-MCTD to reason about the entire problem and avoid the short-sighted pitfalls of simple replanning.
          </p>
          <p>
            We developed three distinct variants of C-MCTD, each designed to tackle different scalability challenges:
          </p>
          <ul>
            <li><strong>Online Composer (OC):</strong> Builds the plan sequentially, using a systematic tree search to ensure each new segment connects coherently with the overall plan.</li>
            <li><strong>Distributed Composer (DC):</strong> Speeds up the search by expanding the plan from multiple points at once, effectively meeting in the middle.</li>
            <li><strong>Preplan Composer (PC):</strong> Achieves maximum efficiency by using a pre-computed "roadmap" of key waypoints to quickly find the optimal path in a graph-based manner.</li>
          </ul>
        </div>
        <!-- Online Composer -->
        <h3 class="title is-4">Online Composer (OC)</h3>
        <div class="content has-text-justified">
          <p>
            <div style="text-align: center;">
              <img src="static/images/online_composer_overview.png" alt="Online Composer Overview" style="width: 90%; height: auto;">
            </div>
            <br>
          </p>
          <p>
            The Online Composer (OC) is our foundational approach to solving the myopic planning problem.
            Instead of simply reacting when a plan ends, OC systematically builds a long-term plan by connecting shorter, high-quality plan segments within a single, coherent tree search.
            This is achieved through three key components.
          </p>
          <p>
            <strong>Stitching-Based Tree Expansion</strong><br>
            To create a plan-level search tree, OC's nodes represent <em>entire, complete plans</em> rather than just partial steps.
            When the tree expands, OC generates a new plan segment $\mathbf{x}^m$ and <strong>stitches</strong> it to the end of the parent node's plan $\mathbf{x}^{1:m-1}$.
            This allows us to construct trajectories that are far longer than the base diffusion planner was trained on, all while using the power of tree search to find a globally optimal solution.
            $$
              \begin{align}
                p_\theta(\mathbf{x}) \approx \prod_{m=1}^{M} p_\theta(\mathbf{x}^m \mid \mathbf{x}^{1:m-1})
              \end{align}
            $$
          </p>
          <p>
            <strong>Guidance Sets as Meta-Actions</strong><br>
            To improve decision-making, we generalize MCTD's "guidance level" into a <strong>guidance set</strong> $\mathcal{G}$.
            At each expansion step, instead of committing to a single guidance strategy (e.g., be conservative or be exploratory), OC considers a flexible set of options.
            This empowers the planner at inference time to select the most effective guidance for generating the next plan segment, leading to more diverse and higher-quality solutions.
            $$
              \begin{align}
                p(\mathbf{x}|\mathcal{G}) \approx \prod_{m=1}^M p(\mathbf{x}^m|\mathbf{x}^{1:m-1}, \mathcal{G}^m)
              \end{align}
            $$
          </p>
          <p>
            <strong>Fast Replanning for Simulation</strong><br>
            To keep the search process efficient, OC needs to quickly evaluate the potential of a partial plan.
            Inspired by "jumpy denoising," it uses <strong>fast replanning</strong>.
            Once a new plan segment is added, the remainder of the trajectory is rapidly generated using an accelerated denoising process.
            This provides a fast, approximate preview of the final outcome, allowing the search algorithm to evaluate rewards without performing a full, computationally expensive simulation.
            $$
              \begin{align}
                \tilde{\mathbf{x}}^{m+1:M} \sim p(\mathbf{x}^{m+1:M}|\mathbf{x}^{1:m}, \mathcal{G}^m)
              \end{align}
            $$
          </p>
          <p>
            <strong>Limitations and the Next Step</strong><br>
            While OC effectively extends planning beyond the limits of its training data, its sequential, piece-by-piece approach can become slow in extremely large environments due to the exponential growth of the search space.
            To address these scalability challenges, we developed our next two variants: <strong>Distributed Composer (DC)</strong> and <strong>Preplan Composer (PC)</strong>.
          </p>
        </div>
        <!-- Distributed / Preplan Composer Algorithms -->
        <div style="text-align: center;">
          <img src="static/images/dc_pc_algorithms.png" alt="Distributed /Preplan Composer Algorithms" style="width: 90%; height: auto;">
        </div>
        <br>
        <!-- Distributed Composer -->
        <h3 class="title is-4">Distributed Composer (DC)</h3>
        <div class="content has-text-justified">
          <p>
            While the Online Composer is effective, its single, sequential search can become prohibitively slow in vast, long-horizon planning tasks.
            To tackle this exponential complexity, we developed the <strong>Distributed Composer (DC)</strong>.
          </p>
          <p>
            The core idea is to "divide and conquer."
            Instead of launching one long search from a single start, DC initiates multiple, smaller MCTS searches in parallel from several strategic starting positions (waypoints) within the environment.
            These parallel searches explore their local areas and then connect with each other to form a global solution.
          </p>
          <p>
            <strong>Guidance-Oriented Parallel Search</strong><br>
            To make these parallel searches efficient, we guide each one toward task-relevant objectives $\mathcal{J}_{\phi}(\mathbf{x})$, each search tree from a starting position $s_i$ is biased to expand in promising directions.
            This ensures that computational effort is focused on explorations that are most likely to contribute to a successful final plan, avoiding wasted effort.
            $$
            \begin{align}
              \tilde{p}_{\theta}(\mathbf{x}|s_i) \propto p_{\theta}(\mathbf{x}|s_i) \exp(\mathcal{J}_{\phi}(\mathbf{x})),
            \end{align}
            $$
          </p>
          <p>
            <strong>Strategic Tree Connection</strong><br>
            To connect the parallel searches, DC uses a strategy to connect the trees only when the plan from one tree reaches the starting point of another tree.
            This transforms the problem into building a "roadmap" between key waypoints, dramatically reducing computational overhead.
            <!--$$
            \begin{align}
              \text{Connect}(\mathcal{T}_i, \mathcal{T}_j) = 
              \begin{cases}
                  \text{True}, & \text{if } \exists~v \in \mathcal{T}_i : \min_{p \in v.\text{trajectory}} \text{dist}(p, s_j) < \epsilon \\
                  \text{False}, & \text{otherwise}
              \end{cases}
            \end{align}
            $$-->
            $$
            \begin{align}
              \text{Connect}(\mathcal{T}_i, \mathcal{T}_j) = 
              \begin{cases}
                  \text{True}, & \begin{aligned}[t]
                                  &\text{if } \exists~v \in \mathcal{T}_i : \\
                                  &\min_{p \in v.\text{trajectory}} \text{dist}(p, s_j) < \epsilon
                                \end{aligned} \\
                  \text{False}, & \text{otherwise}
              \end{cases}
            \end{align}
            $$
          </p>
          <p>
            <strong>Efficient Path Synthesis</strong><br>
            Once the parallel searches have run and formed a connectivity graph (our "roadmap"), DC uses a classic shortest-path algorithm like Dijkstra's or A* to instantly find the optimal path from the start to the goal.
            This final step synthesizes the local plans discovered by the parallel searches into a single, globally optimal solution.
          </p>
          <p>
            <strong>Remaining Challenges</strong><br>
            By parallelizing the search, DC significantly reduces the search depth and scales far better than OC.
            However, it still performs all of this computationally intensive tree search at inference time.
            To address this, we introduce our final and most efficient variant: <strong>Preplan Composer (PC)</strong>.
          </p>
        </div>
        <!-- Distributed Composer -->
        <h3 class="title is-4">Preplan Composer (PC)</h3>
        <div class="content has-text-justified">
          <p>
            Our final variant, the <strong>Preplan Composer (PC)</strong>, addresses the last major hurdle: the heavy computational cost of performing tree searches at inference time.
            While the Distributed Composer parallelizes the search, it still has to do all that work "live."
            PC introduces a simple yet powerful idea: what if we do all the heavy exploration work <em>beforehand</em>?
          </p>
          <p>
            PC shifts the expensive process of discovering paths into an offline, one-time pre-computation step. This allows for nearly instantaneous planning when a new task is given. It operates in two distinct phases.
          </p>
          <p>
            <strong>Phase 1 (Offline): Building the Connectivity Graph</strong><br>
            In the offline phase, we use our Online Composer to thoroughly explore the environment and build a comprehensive "roadmap" between the waypoints.
            This roadmap is stored as a graph where the nodes are strategic waypoints and the edges are high-quality, pre-computed plans that connect them.
            <em>This computationally intensive step only needs to be performed once.</em>
            $$
              \begin{align}
                \tilde{p}_{\theta}(\mathbf{x}|s_i) \propto p_{\theta}(\mathbf{x}|s_i) \exp(-\text{dist}(\mathbf{x},s_j)),
              \end{align}
            $$
          </p>
          <p>
            <strong>Phase 2 (Online): Lightning-Fast Graph-Based Planning</strong><br>
            Once a planning task is requested at inference time, the hard work is already done.
            PC simply connects the given start and goal states to their nearest waypoints in the pre-computed graph.
            Then, it uses a classical shortest-path finding algorithm (like A*) to find the optimal path along the existing roadmap.
            <em>No complex tree search is required at inference time.</em>
          </p>
          <p>
            By pre-computing the solution space, PC makes long-horizon planning incredibly efficient at inference time, making it ideal for applications where speed is critical.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>
<!-- End C-MCTD -->

<!-- Experiment results -->
<section class="section hero is-light">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Experimental Results</h2>
        <div class="content has-text-justified">
          <p>
            To demonstrate the effectiveness of C-MCTD, we conducted a comprehensive evaluation using challenging benchmarks from OGBench as done in the original MCTD paper.
            Our experiments cover three key domains: <strong>(1) long-horizon maze navigation</strong>, <strong>(2) multi-object robot arm manipulation</strong>, and <strong>(3) high-dimensional visual navigation</strong>.
          </p>
        </div>
        <h3 class="title is-4">Long-Horizon Maze Navigation 🗺️ </h3>
        <div class="content has-text-justified">
            <p>
                First, we tested our methods on maze navigation tasks that require planning trajectories far longer than those seen during training.
                This experiment highlights how well C-MCTD generalizes beyond its training data.
            </p>
            <div class="has-text-centered">
              <img src="static/images/maze_navigation_results.png" alt="Maze Navigation Results" style="width: 90%; height: auto;">
                <br>
            </div>
            <ul>
                <li><strong>Baselines Struggle to Scale:</strong> As the maze complexity increased (medium → giant), most baseline methods failed completely, with success rates dropping to 0% in the largest "giant" maze.</li>
                <li><strong>C-MCTD Shows Superior Scalability:</strong> In contrast, our C-MCTD variants, especially the <em>Preplan Composer</em>, achieved a perfect 100% success rate on the most difficult PointMaze-Giant task, demonstrating outstanding scalability.</li>
                <li><strong>Efficiency Gains:</strong> The <em>Preplan Composer</em> was also the fastest planner in C-MCTD and produced the highest-quality (shortest) paths, clearly showing the benefits of its offline pre-planning strategy.</li>
            </ul>
        </div>
        <h3 class="title is-4">Multi-Object Manipulation 🤖</h3>
        <div class="content has-text-justified">
            <p>
                Next, we evaluated C-MCTD on a robotic arm manipulation task requiring it to stack multiple cubes in a specific order, a test of precise sequential planning.
            </p>
        
            <div class="has-text-centered">
              <img src="static/images/multi_object_manipulation_results.png" alt="Multi-Object Manipulation Results" style="width: 90%; height: auto;">
            </div>
            <ul>
                <li><strong>Baselines Degrade with Complexity:</strong> As the number of cubes increased, the success rates of baseline methods dropped significantly (e.g., MCTD-Replan fell from 100% to 24%).</li>
                <li><strong>C-MCTD Excels at Compositional Reasoning:</strong> Our <em>Online Composer</em>, enhanced with a Plan Cache (to avoid re-planning the same plan multiple times), maintained a high 82% success rate on the most difficult four-cube task, proving its ability to solve complex compositional problems.</li>
            </ul>
        </div>
        <h3 class="title is-4">High-Dimensional Visual Navigation 👀</h3>
        <div class="content has-text-justified">
            <p>
                Finally, we applied C-MCTD to a challenging visual navigation task where the agent must find its way from raw RGB image observations. This partially observable setting mimics real-world scenarios.
            </p>
            <div class="has-text-centered">
              <img src="static/images/high_dimensional_visual_navigation_results.png" alt="High-Dimensional Visual Navigation Results" style="width: 40%; height: auto;">
            </div>
            <ul>
                <li><strong>Myopic Planning Fails:</strong> In this difficult setting, the limitations of myopic (short-sighted) planning were clear, with baselines performing very poorly on the more complex maze.</li>
                <li><strong>C-MCTD's Plan-Level Search Succeeds:</strong> Our <em>Online Composer</em> significantly outperformed all baselines, achieving a 54% success rate on the large maze (vs. 20% for the best baseline), highlighting the benefit of reasoning over the entire plan.</li>
                <li><strong>Future Research Direction:</strong> Interestingly, the <em></em>Distributed Composer</em> and <em>Preplan Composer</em> variants underperformed here. This suggests that identifying meaningful waypoints in high-dimensional visual space is a key challenge and an important direction for future work.</li>
            </ul>
        </div>
      </div>
    </div>
  </div>
</section>
<!-- End Experiment results -->

<!-- paper conclusion -->
<section class="section hero is-light">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Conclusion</h2>
        <div class="content has-text-justified">
          <p>
            We introduced Compositional Monte Carlo Tree Diffusion (C-MCTD), a novel framework that scales diffusion-based planners to generate complex, long-horizon plans by composing shorter trajectories at inference time.
            C-MCTD integrates three complementary approaches: the <strong>Online Composer</strong> for flexible, on-the-fly plan generation; the <strong>Distributed Composer</strong> for scaling through parallelism; and the <strong>Preplan Composer</strong> for maximum efficiency via pre-computed plan graphs.
            Our extensive evaluations show that this compositional framework significantly outperforms conventional replanning strategies.
            Notably, the <strong>Preplan Composer</strong> solves tasks requiring trajectories up to $10\times$ longer than those seen during training.
            These results demonstrate that compositional scaling at inference time can dramatically enhance the reasoning capabilities of diffusion planners.
            Crucially, this is achieved without any model retraining, offering a practical and effective path toward more capable agents for challenging sequential decision-making problems.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>
<!-- End paper conclusion -->

<!--BibTex citation -->
  <section class="section" id="BibTeX">
    <div class="container is-max-desktop content">
      <h2 class="title">BibTeX</h2>
      <pre><code>
        @article{yoon2025compositional,
          title={Compositional Monte Carlo Tree Diffusion for Extendable Planning},
          author={Yoon, Jaesik and Cho, Hyeonseo and Ahn, Sungjin},
          journal={arXiv preprint arXiv:2510.21361},
          year={2025}
        }
      </code></pre>
    </div>
</section>
<!--End BibTex citation -->


  <footer class="footer">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content">

          <p>
            This page was built using the <a href="https://github.com/eliahuhorwitz/Academic-project-page-template" target="_blank">Academic Project Page Template</a> which was adopted from the <a href="https://nerfies.github.io" target="_blank">Nerfies</a> project page.
            You are free to borrow the source code of this website, we just ask that you link back to this page in the footer. <br> This website is licensed under a <a rel="license"  href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative
            Commons Attribution-ShareAlike 4.0 International License</a>.
          </p>

        </div>
      </div>
    </div>
  </div>
</footer>

<!-- Statcounter tracking code -->
  
<!-- You can add a tracker to track page visits by creating an account at statcounter.com -->

    <!-- End of Statcounter Code -->

  </body>
  </html>
